June 2002.

   #####   Statement for Known Bugs for   #####
   ##### GeoFEM's Linear Solver Subsystem #####

1.FEATURE
GeoFEM's linear solver subsystem does not work
if :

  - the entire problem size is small.
  - many PE's
  - more precisely, 'NP < STACK_EXPORT(NEIBPETOT)'

In this case, working array size for communication is
not sufficient, therefore communication among PE's fail.

2.REMEDY for SCALAR SOLVERS
If you want to solve such problems that satisfy above conditions,
please change subroutines for iterative linear solver in the 
following manner. This example is only for SCALAR solvers but
you can easily apply this procedure to BLOCK solvers.

If you have any questions, please feel free to contact
us via e-mail at 'geofem-comment@tokyo.rist.or.jp'.

(1) define scalar 'NN' as follows in each subroutine for
    individual iterative method such as 'solver_CG.f90',
    'solver_BiCGSTAB.f90' etc.

     integer(kind=kint ) :: NN
     NN= max (NP, STACK_EXPORT(NEIBPETOT)

(2) allocate array 'WS' and 'WR' for communication as follows:

    -exsisting version: allocate (WS(NP), WR(NP))
    -new version      : allocate (WS(NN), WR(NN))

(3) change interface with subroutine 'SOLVER_SEND_RECV' as follows:

    -existing version:
          call SOLVER_SEND_RECV                                         &
     &       ( NP, NEIBPETOT, NEIBPE, STACK_IMPORT, NOD_IMPORT,         &
     &         STACK_EXPORT, NOD_EXPORT, WS, WR, SCALE)

    -new version:
          call SOLVER_SEND_RECV                                         &
     &       ( NP, NN, NEIBPETOT, NEIBPE, STACK_IMPORT, NOD_IMPORT,     &
                   --
     &         STACK_EXPORT, NOD_EXPORT, WS, WR, SCALE)

(4) substitute file 'solver_SR.f90' with the following file and re-compile.

      module solver_SR
      contains

      subroutine  SOLVER_SEND_RECV                                      &
     &                ( N, NN,                                          &
     &                     NEIBPETOT, NEIBPE, STACK_IMPORT, NOD_IMPORT, &
     &                                        STACK_EXPORT, NOD_EXPORT, &
     &                  WS, WR, X)

      implicit REAL*8 (A-H,O-Z)
      include  'mpif.h'
      include  'precision.inc'

      integer(kind=kint )                , intent(in)   ::  N
      integer(kind=kint )                , intent(in)   ::  NEIBPETOT
      integer(kind=kint ), pointer :: NEIBPE      (:)
      integer(kind=kint ), pointer :: STACK_IMPORT(:)
      integer(kind=kint ), pointer :: NOD_IMPORT  (:)
      integer(kind=kint ), pointer :: STACK_EXPORT(:)
      integer(kind=kint ), pointer :: NOD_EXPORT  (:)
      real   (kind=kreal), dimension(NN) , intent(inout):: WS
      real   (kind=kreal), dimension(NN) , intent(inout):: WR
      real   (kind=kreal), dimension(N)  , intent(inout):: X

      integer(kind=kint ), dimension(:,:), save, allocatable :: sta1
      integer(kind=kint ), dimension(:,:), save, allocatable :: sta2
      integer(kind=kint ), dimension(:  ), save, allocatable :: req1
      integer(kind=kint ), dimension(:  ), save, allocatable :: req2

      integer(kind=kint ), save :: NFLAG
      data NFLAG/0/

!C
!C-- INIT.
      if (NFLAG.eq.0) then
        allocate (sta1(MPI_STATUS_SIZE,NEIBPETOT))
        allocate (sta2(MPI_STATUS_SIZE,NEIBPETOT))
        allocate (req1(NEIBPETOT))
        allocate (req2(NEIBPETOT))
        NFLAG= 1
      endif

!C
!C-- SEND

      do neib= 1, NEIBPETOT
        istart= STACK_EXPORT(neib-1)
        inum  = STACK_EXPORT(neib  ) - istart

        do k= istart+1, istart+inum
           WS(k)= X(NOD_EXPORT(k))
        enddo
        call MPI_ISEND (WS(istart+1), inum, MPI_DOUBLE_PRECISION,       &
     &                  NEIBPE(neib), 0, CALYPSO_COMM,                  &
     &                  req1(neib), ierr)
      enddo

!C
!C-- RECEIVE

      do neib= 1, NEIBPETOT
        istart= STACK_IMPORT(neib-1)
        inum  = STACK_IMPORT(neib  ) - istart
        call MPI_IRECV (WR(istart+1), inum, MPI_DOUBLE_PRECISION,       &
     &                  NEIBPE(neib), 0, CALYPSO_COMM,                  &
     &                  req2(neib), ierr)
      enddo

      call MPI_WAITALL (NEIBPETOT, req2, sta2, ierr)

      do neib= 1, NEIBPETOT
        istart= STACK_IMPORT(neib-1)
        inum  = STACK_IMPORT(neib  ) - istart
      do k= istart+1, istart+inum
        X(NOD_IMPORT(k))= WR(k)
      enddo
      enddo

      call MPI_WAITALL (NEIBPETOT, req1, sta1, ierr)

      end subroutine solver_send_recv
      end module     solver_SR


